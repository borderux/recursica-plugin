#!/usr/bin/env node

/**
 * Design Review Automation Script
 *
 * This script automates the design review workflow by:
 * 1. Creating a new design review branch with a unique name based on the user and timestamp
 * 2. Committing any pending changes to the branch
 * 3. Generating and committing theme-related files
 * 4. Pushing changes to GitLab
 * 5. Running Chromatic for visual testing
 * 6. Providing a merge request URL for review
 *
 * Usage: npm run design-review
 *
 * Requirements:
 * - Git configuration with user.name set
 * - GitLab repository
 * - Chromatic project setup
 */

import { execSync } from 'child_process';
import readline from 'readline';

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

const question = (query: string) =>
  new Promise<string>((resolve) => {
    rl.question(query, resolve);
  });

function getCurrentBranch() {
  try {
    return execSync('git rev-parse --abbrev-ref HEAD', { stdio: 'pipe' }).toString().trim();
  } catch (error: unknown) {
    console.error('Error getting current branch:', (error as Error).message);
    process.exit(1);
  }
}

function getGitUser() {
  try {
    const user = execSync('git config user.name', { stdio: 'pipe' }).toString().trim();
    // Sanitize the username to be safe for branch names
    return user.replace(/[^a-zA-Z0-9-]/g, '-');
  } catch (error: unknown) {
    console.error('Error getting GitLab user:', (error as Error).message);
    process.exit(1);
  }
}

function getRemoteUrl() {
  try {
    return execSync('git config --get remote.origin.url', { stdio: 'pipe' }).toString().trim();
  } catch (error: unknown) {
    console.error('Error getting remote URL:', (error as Error).message);
    process.exit(1);
  }
}

function createNewBranch() {
  const gitlabUser = getGitUser();
  const timestamp = Math.floor(Date.now() / 1000).toString();
  const branchName = `design-review/${gitlabUser}/${timestamp}`;

  try {
    execSync(`git checkout -b "${branchName}"`, { stdio: 'pipe' });
    console.log(`Created and switched to new branch: ${branchName}`);
    return branchName;
  } catch (error: unknown) {
    console.error('Error creating new branch:', (error as Error).message);
    process.exit(1);
  }
}

async function handleExistingDesignReviewBranch(branchName: string) {
  const answer: string = await question(
    'You are in a design-review branch. Do you want to create a new review process? (y/n): '
  );

  if (answer.toLowerCase() === 'y') {
    return createNewBranch();
  }
  return branchName;
}

async function flow(currentBranch: string) {
  if (currentBranch === 'main') {
    console.log('You are in main branch. Creating a new design review branch...');
    createNewBranch();
  } else if (currentBranch.startsWith('design-review/')) {
    await handleExistingDesignReviewBranch(currentBranch);
  } else {
    console.log('You are not in a design-review branch. Creating a new one...');
    createNewBranch();
  }

  // Check if there are any files to add and commit
  const status = execSync('git status --porcelain', { stdio: 'pipe' }).toString().trim();
  console.log('Checking if files have changed... "', status, '"');
  // eslint-disable-next-line no-extra-boolean-cast
  if (!!status) {
    console.log('Adding modified files to your commit...');
    // Add and commit files
    execSync('git add .', { stdio: 'pipe' });
    const gitlabUser = getGitUser();
    execSync(`git commit -m "Recursica JSON files added by ${gitlabUser}"`, { stdio: 'pipe' });
    console.log('Files committed successfully');
  } else {
    console.log('It looks like there were no changed files, so nothing to do.  Exiting...');
    process.exit(0);
  }

  // Generate theme
  console.log('Generating theme...');
  try {
    execSync('npm run recursica');
    console.log('Theme generated successfully');
  } catch (error: unknown) {
    console.error('Error generating theme:', (error as Error).message);
    process.exit(1);
  }

  // Check if there are any changes to commit after theme generation
  const postThemeStatus = execSync('git status --porcelain', { stdio: 'pipe' }).toString();
  if (postThemeStatus.trim()) {
    // Commit generated files
    execSync('git add .', { stdio: 'pipe' });
    execSync('git commit -m "adapter autogenerated files added"', { stdio: 'pipe' });
    console.log('Generated files committed successfully');
  } else {
    console.log('No new files were generated');
  }

  // Push changes
  console.log('Pushing changes...');
  execSync('git push -u origin HEAD --porcelain', { stdio: 'pipe' });
}

function runChromatic() {
  // Run Chromatic
  console.log('Running Chromatic build...');
  try {
    execSync('npm run chromatic', { stdio: 'pipe' });
    console.log('Chromatic build completed successfully');
  } catch (error: unknown) {
    const chromaticLink = /https:\/\/www\.chromatic\.com\/build\?appId=[\w-]+&number=[\d]+/.exec(
      (error as Error).message
    )?.[0];
    if (chromaticLink) {
      console.info(`New changes are available at ${chromaticLink} to be reviewed.`);
      process.exit(0);
    } else {
      console.error('Chromatic build failed:', (error as Error).message);
      process.exit(1);
    }
  }
}

function getProjectPath(remoteUrl: string): { path: string; isGitHub: boolean } {
  // Remove .git suffix and any /tree/branch-name
  const cleanUrl = remoteUrl.replace(/\.git$/, '').replace(/\/tree\/.*$/, '');

  // Handle SSH URLs
  if (cleanUrl.startsWith('git@')) {
    const match = /git@(?:github|gitlab(?:-[\w]+)?)\.com(?:-[\w]+)?:(.+)/.exec(cleanUrl);
    if (!match) throw new Error('Invalid remote URL format 1');
    return {
      path: match[1],
      isGitHub: cleanUrl.includes('github.com'),
    };
  }

  // Handle HTTPS URLs
  const match = /https:\/\/(?:github|gitlab(?:-[\w]+)?)\.com\/(.+)/.exec(cleanUrl);
  if (!match) throw new Error('Invalid remote URL format 2');
  return {
    path: match[1],
    isGitHub: cleanUrl.includes('github.com'),
  };
}

function constructMergeRequestUrl(projectPath: string, branch: string, isGitHub: boolean): string {
  const encodedBranch = encodeURIComponent(branch);

  if (isGitHub) {
    return `https://github.com/${projectPath}/pull/new/${encodedBranch}`;
  }

  return `https://gitlab.com/${projectPath}/-/merge_requests/new?merge_request%5Bsource_branch%5D=${encodedBranch}`;
}

function createMergeRequest(currentBranch: string) {
  // Get remote URL and construct MR URL
  const remoteUrl = getRemoteUrl();
  const { path, isGitHub } = getProjectPath(remoteUrl);
  const mergeRequestUrl = constructMergeRequestUrl(path, currentBranch, isGitHub);
  console.log(`Merge request URL: ${mergeRequestUrl}`);
}

async function main() {
  try {
    console.log('Running Recursica design review process');
    // Check if there are any changes before proceeding
    execSync('git fetch --prune', { stdio: 'pipe' });
    const initialStatus = execSync('git status --porcelain', { stdio: 'pipe' }).toString().trim();

    const currentBranch = getCurrentBranch();
    if (!initialStatus) {
      if (currentBranch.startsWith('design-review/')) {
        const answer = await question(
          'No changed files detected in a design review branch. Have you already reviewed the changes in Chromatic? (y/n): '
        );
        if (answer.toLowerCase() === 'y') {
          runChromatic();
          createMergeRequest(currentBranch);
          process.exit(0);
        }
      } else {
        console.log(
          'No files changed. Please add modified Recursica JSON files before running this. Exiting...'
        );
      }
      process.exit(1);
    }

    await flow(currentBranch);

    runChromatic();

    createMergeRequest(currentBranch);
  } catch (error: unknown) {
    console.error('An error occurred:', (error as Error).message);
    process.exit(1);
  } finally {
    rl.close();
  }
}

void main();

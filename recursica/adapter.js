'use strict';

/**
 * Type guard function to check if a token is a FontFamilyToken
 *
 * @param token - The token to check
 * @returns True if the token has fontFamily and variableName properties, indicating it's a FontFamilyToken
 */
function isFontFamilyToken(token) {
  return 'fontFamily' in token && 'variableName' in token;
}
/**
 * Type guard function to check if a token is an EffectToken
 *
 * @param token - The token to check
 * @returns True if the token has effects and variableName properties, indicating it's an EffectToken
 */
function isEffectToken(token) {
  return 'effects' in token && 'variableName' in token;
}
/**
 * Type guard function to check if a token is a basic Token (color or float)
 *
 * @param token - The token to check
 * @returns True if the token has mode, type, name, and value properties, indicating it's a basic Token
 */
function isColorOrFloatToken(token) {
  return 'mode' in token && 'type' in token && 'name' in token && 'value' in token;
}

function autoGeneratedFile() {
  return `/* prettier-ignore */
/* eslint-disable */
/* tslint:disable */
/*
Auto-generated by Recursica.
Do NOT edit these files directly\n
For more information about Recursica, go to https://recursica.com
*/
`;
}

function capitalize(str) {
  return str.replace(/-/g, ' ').replace(/\b\w/g, (char) => char.toUpperCase());
}

function parseValue(value, recursicaTokens) {
  if (typeof value === 'object') {
    if (value.collection === 'Tokens') {
      return `${recursicaTokens}["${value.name}"]`;
    }
    if (value.collection === 'Themes') {
      return `themeVars["${value.name}"]`;
    }
  } else if (!isNaN(Number(value))) {
    return `"${value}"`;
  }
  return `"${value.toString()}"`;
}
function generateVanillaExtractThemes(
  tokens,
  themes,
  recursicaTokensFilename,
  { outputPath, project }
) {
  const themesContent = [];
  // Contract tokens
  const themeContractFilename = `Recursica${project}ContractTheme.css`;
  const contractThemeOutputPath = outputPath + '/' + `${themeContractFilename}.ts`;
  const contractTokens = {};
  const themeDef = {};
  for (const [rawThemeName, currentTheme] of Object.entries(themes)) {
    for (const [key, theme] of Object.entries(currentTheme)) {
      const currentThemeName = capitalize(rawThemeName);
      const recursicaTokens = `Recursica${project}Tokens`;
      const themeKey = key.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
      const themeName = `${currentThemeName}${themeKey}Theme`;
      if (!themeDef[currentThemeName]) {
        themeDef[currentThemeName] = {};
      }
      themeDef[currentThemeName][themeKey] = themeName;
      const generatedThemeContent = `${autoGeneratedFile()}
import { createTheme } from '@vanilla-extract/css';

import { themeVars } from './${themeContractFilename.replace('.ts', '')}'
import { ${recursicaTokens} } from './${recursicaTokensFilename.replace('.ts', '')}'

export const ${themeName} = createTheme(themeVars,{
  ${Object.entries(theme)
    .map(([key, value]) => {
      contractTokens[key] = null;
      return `'${key}': ${parseValue(value, recursicaTokens)}`;
    })
    .join(',\n\t')},
  ${Object.entries(tokens?.[rawThemeName] ?? {})
    .map(([key, value]) => {
      contractTokens[key] = null;
      return `'${key}': ${parseValue(value, recursicaTokens)}`;
    })
    .join(',\n\t')}
})`;
      themesContent.push({
        name: themeName,
        content: generatedThemeContent,
      });
    }
  }
  let themesFileContent = autoGeneratedFile();
  const vanillaExtractThemes = [];
  for (const theme of themesContent) {
    const themeName = `Recursica${project}${theme.name}`;
    const autoGeneratedThemeFilename = `${themeName}.css.ts`;
    const themeFilePath = outputPath + '/' + autoGeneratedThemeFilename;
    vanillaExtractThemes.push({
      content: theme.content,
      path: themeFilePath,
      filename: autoGeneratedThemeFilename,
    });
    // generate a theme.css.ts where we import all the themes using just 1 variables (1 export)
    themesFileContent += `export { ${theme.name} } from './${autoGeneratedThemeFilename.replace('.ts', '')}';\n`;
    themesFileContent += `import { ${theme.name} } from './${autoGeneratedThemeFilename.replace('.ts', '')}';\n`;
  }
  themesFileContent += `\nexport const Themes = {
  ${Object.entries(themeDef)
    .map(
      ([key, value]) => `'${key}': {
    ${Object.entries(value)
      .map(([key, value]) => `'${key}': ${value}`)
      .join(',\n\t\t')}`
    )
    .join('\n\t},\n\t')}
  }
}`;
  // create the themes.ts file
  const availableThemesContent = `${autoGeneratedFile()}
export const AvailableThemes = [${themesContent.map((theme) => `"${theme.name}"`).join(', ')}] as const;
export type AvailableThemesType = (typeof AvailableThemes)[number];
`;
  const availableThemesPath = outputPath + '/types.ts';
  const themeContractContent = `${autoGeneratedFile()}
import { createThemeContract } from '@vanilla-extract/css';

export const themeVars = createThemeContract(${JSON.stringify(contractTokens, null, 2)});
`;
  const themesFilename = `Recursica${project}Themes.css.ts`;
  const themesFilePath = outputPath + '/' + themesFilename;
  return {
    themesFileContent: {
      content: themesFileContent,
      path: themesFilePath,
      filename: themesFilename,
    },
    availableThemes: {
      content: availableThemesContent,
      path: availableThemesPath,
      filename: 'types.ts',
    },
    vanillaExtractThemes,
    themeContract: {
      content: themeContractContent,
      path: contractThemeOutputPath,
      filename: themeContractFilename,
    },
    contractTokens,
  };
}

function generateRecursicaTokens(baseTokens, { outputPath, project }) {
  const recursicaTokensFilename = `Recursica${project}Tokens.ts`;
  const recursicaTokensPath = outputPath + '/' + recursicaTokensFilename;
  const recursicaTokensContent = `${autoGeneratedFile()}
export const Recursica${project}Tokens = {
  ${Object.entries(baseTokens)
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    .filter(([_, value]) => typeof value === 'string')
    .map(([key, value]) => `"${key}": "${value}"`)
    .join(',\n  ')}
};
`;
  return {
    content: recursicaTokensContent,
    path: recursicaTokensPath,
    filename: recursicaTokensFilename,
  };
}

function generateUiKit(
  uiKit,
  { recursicaTokensFilename, themeContractFilename },
  { outputPath, project }
) {
  const uiKitFilename = `Recursica${project}UiKit.ts`;
  const uiKitPath = outputPath + '/' + uiKitFilename;
  const recursicaTokens = `Recursica${project}Tokens`;
  const uiKitContent = `${autoGeneratedFile()}
import { themeVars } from './${themeContractFilename.replace('.ts', '')}'
import { ${recursicaTokens} } from './${recursicaTokensFilename.replace('.ts', '')}'

export const uiKit = {
  ${Object.entries(uiKit)
    .map(([key, value]) => `'${key}': ${parseValue(value, recursicaTokens)}`)
    .join(',\n\t')}\n\t}`;
  return {
    content: uiKitContent,
    path: uiKitPath,
    filename: uiKitFilename,
  };
}

function parseKey(key) {
  return key.replaceAll('/', '-');
}
function generateMantineTheme({
  mantineThemeOverride,
  tokens,
  breakpoints,
  contractTokens: { tokens: contractTokens, filename: contractFilename },
  exportingProps: { outputPath, project },
}) {
  const themeTokens = {
    colors: {},
    radius: {},
    fontSizes: {},
    primaryColor: mantineThemeOverride?.['1-scale'],
    white: mantineThemeOverride?.background,
  };
  for (const [key, value] of Object.entries(tokens)) {
    if (typeof value === 'object') continue;
    if (key.includes('border-radius')) {
      themeTokens.radius[parseKey(key)] = value;
    }
    if (key.includes('font/size')) {
      themeTokens.fontSizes[parseKey(key)] = `"${value}"`;
    }
  }
  for (const [key] of Object.entries(contractTokens)) {
    if (key.includes('color/') || key.includes('color-on/')) {
      themeTokens.colors[parseKey(key)] = `themeVars['${key}']`;
    }
    if (/font\/(\w+)\/size/.test(key)) {
      themeTokens.fontSizes[parseKey(key)] = `themeVars['${key}']`;
    }
  }
  const postCssFilename = 'postcss.config.cjs';
  let postCssContent = `${autoGeneratedFile()}\n`;
  postCssContent += `module.exports = {
  plugins: {
    'postcss-preset-mantine': {},
    'postcss-simple-vars': {
      variables: {`;
  for (const [key, value] of Object.entries(breakpoints)) {
    postCssContent += `\n\t\t\t\t'mantine-breakpoint-${key}': '${value}',`;
  }
  postCssContent += `
      }
    }
  }
}`;
  const postCssFileContent = {
    content: postCssContent,
    path: postCssFilename,
    filename: postCssFilename,
  };
  const fileContent = `${autoGeneratedFile()}
import { colorsTuple, createTheme } from '@mantine/core'
import { themeVars } from './${contractFilename.replace('.ts', '')}'

export const mantineTheme = createTheme({
  ${themeTokens.primaryColor ? `primaryColor: ${themeTokens.primaryColor},` : ''}
  ${themeTokens.white ? `white: ${themeTokens.white},` : ''}
  breakpoints: {
    ${Object.entries(breakpoints)
      .map(([key, value]) => `'${key}': '${value}'`)
      .join(',\n\t\t')}
  },
  colors: {
    ${Object.entries(themeTokens.colors)
      .map(([key, value]) => `"${key}": colorsTuple(${value})`)
      .join(',\n\t\t')}
  },
  radius: {
    ${Object.entries(themeTokens.radius)
      .map(([key, value]) => `"${key}": "${value}"`)
      .join(',\n\t\t')}
  },
  fontSizes: {
    ${Object.entries(themeTokens.fontSizes)
      .map(([key, value]) => `"${key}": ${value}`)
      .join(',\n\t\t')}
  }
})`;
  const filename = `Recursica${project}MantineTheme.ts`;
  const mantineThemeFileContent = {
    content: fileContent,
    path: outputPath + '/' + filename,
    filename,
  };
  return { mantineTheme: mantineThemeFileContent, postCss: postCssFileContent };
}

function createRecursicaObject(project, outputPath) {
  const tokens = `Recursica${project}Tokens`;
  const contract = `Recursica${project}ContractTheme`;
  const uiKit = `Recursica${project}UiKit`;
  const recursicaObjectContent = `${autoGeneratedFile()}
import { ${tokens} } from './${tokens}';
import { themeVars } from './${contract}.css';
import { uiKit } from './${uiKit}';

export const recursica = {
  ...uiKit,
  ...themeVars,
  ...${tokens},
}
`;
  return {
    content: recursicaObjectContent,
    path: outputPath + '/Recursica.ts',
    filename: 'Recursica.ts',
  };
}

function generateColorsType(colorTokens, outputPath) {
  const colorsType = `${autoGeneratedFile()}
export type RecursicaColors = \n\t"${colorTokens.join('" |\n\t"')}";\n`;
  return {
    content: colorsType,
    path: `${outputPath}/RecursicaColorsType.ts`,
    filename: 'RecursicaColorsType.ts',
  };
}

function generateIcons(icons, srcPath, config) {
  let iconsPath;
  if (!config?.output) {
    iconsPath = srcPath + '/components' + '/Icons';
  } else {
    iconsPath = srcPath + '/' + config.output;
  }
  const svgPath = iconsPath + '/Svg';
  const exportedIcons = [];
  // Generate svg files
  for (const [rawIconName, iconPath] of Object.entries(icons)) {
    const [iconName, variant] = rawIconName.split('[');
    let cleanIconName = iconName.replaceAll('-', '_');
    // check if the iconName is in the names array, if not, skip
    if (!config?.names?.includes(cleanIconName)) {
      continue;
    }
    // detect if the iconName starts with a number, if so, add an underscore to the beginning
    if (cleanIconName.match(/^\d/)) {
      cleanIconName = `_${cleanIconName}`;
    }
    const cleanVariant = variant.replace(']', '').replace('Style=', '');
    const codedVariant = cleanVariant.replaceAll(' ', '_');
    // check if the codedVariant is in the variants array, if not, skip
    if (!config?.variants?.includes(codedVariant)) {
      continue;
    }
    const finalIconName = `${cleanIconName}_${codedVariant}`;
    exportedIcons.push({
      content: iconPath.replaceAll('fill="black"', '').replaceAll('fill="none"', ''),
      path: `${svgPath}/${finalIconName}.svg`,
      filename: `${finalIconName}`,
    });
  }
  // Generate icon exports file
  const exportsPath = iconsPath + '/icon_exports.ts';
  let exportsContent = `${autoGeneratedFile()}
/// <reference types="vite-plugin-svgr/client" />\n`;
  for (const icon of exportedIcons) {
    exportsContent += `import ${icon.filename} from './Svg/${icon.filename}.svg?react';\n`;
    exportsContent += `export { ${icon.filename} };\n`;
  }
  // Generate icon map file
  const mapPath = iconsPath + '/icon_resource_map.ts';
  let mapContent = `${autoGeneratedFile()}\nimport * as IconExports from './icon_exports';\n\n`;
  mapContent += 'export const IconResourceMap = {';
  mapContent += exportedIcons
    .map((icon) => `\n\t'${icon.filename}': IconExports.${icon.filename},`)
    .join('');
  mapContent += '\n};\n';
  return {
    exportedIcons,
    iconExports: {
      content: exportsContent,
      path: exportsPath,
      filename: 'icon_exports.ts',
    },
    iconResourceMap: {
      content: mapContent,
      path: mapPath,
      filename: 'icon_resource_map.ts',
    },
  };
}

function runAdapter({
  overrides,
  srcPath,
  tokens,
  themes,
  project,
  uiKit,
  colors,
  icons,
  breakpoints,
  iconsConfig,
}) {
  const outputPath = srcPath + '/recursica';
  const recursicaTokens = generateRecursicaTokens(tokens, { outputPath, project });
  const vanillaExtractThemes = generateVanillaExtractThemes(
    tokens,
    themes,
    recursicaTokens.filename,
    {
      outputPath,
      project,
    }
  );
  const mantineTheme = generateMantineTheme({
    mantineThemeOverride: overrides?.mantineTheme,
    tokens,
    breakpoints,
    contractTokens: {
      tokens: vanillaExtractThemes.contractTokens,
      filename: vanillaExtractThemes.themeContract.filename,
    },
    exportingProps: {
      outputPath,
      project,
    },
  });
  const uiKitObject = generateUiKit(
    uiKit,
    {
      recursicaTokensFilename: recursicaTokens.filename,
      themeContractFilename: vanillaExtractThemes.themeContract.filename,
    },
    { outputPath, project }
  );
  const recursicaObject = createRecursicaObject(project, outputPath);
  const colorsType = generateColorsType(colors, outputPath);
  let iconsObject;
  if (icons) {
    iconsObject = generateIcons(icons, srcPath, iconsConfig);
  }
  const fileContents = {
    recursicaTokens,
    vanillaExtractThemes,
    mantineTheme,
    uiKitObject,
    recursicaObject,
    colorsType,
    iconsObject,
  };
  return fileContents;
}

const tokens = {};
const breakpoints = {};
const colorTokens = [];
const icons = {};
const themes = {};
const uiKit = {};
function processTokenValue(token, modeName, jsonThemeName) {
  const processValue = (target) => {
    if (typeof token.value === 'string') {
      target[token.name] = token.value;
      return true;
    }
    if (typeof token.value === 'number') {
      target[token.name] = `${token.value}px`;
      return true;
    }
    if (typeof token.value === 'object') {
      target[token.name] = token.value;
      return true;
    }
    return false;
  };
  if (token.collection === 'Breakpoints') {
    processValue(breakpoints);
    // Add breakpoints to uiKit with 'breakpoints/' prefix
    const uiKitTarget = {};
    processValue(uiKitTarget);
    Object.entries(uiKitTarget).forEach(([key, value]) => {
      // Ensure we only store string values
      if (typeof value === 'string') {
        uiKit[`breakpoint/${key}`] = value;
      } else if (typeof value === 'number') {
        uiKit[`breakpoint/${key}`] = `${value.toString()}px`;
      }
    });
  } else if (token.collection === 'UI Kit') {
    processValue(uiKit);
  } else if (token.collection === 'Tokens') {
    processValue(tokens);
  } else {
    if (!jsonThemeName) return;
    if (!themes[jsonThemeName]) themes[jsonThemeName] = {};
    if (!themes[jsonThemeName][modeName]) themes[jsonThemeName][modeName] = {};
    processValue(themes[jsonThemeName][modeName]);
  }
}
function processTokens(variables, { tokens, themes, overrides }, jsonThemeName) {
  // Process tokens collection
  for (const token of Object.values(variables)) {
    if (isFontFamilyToken(token)) {
      if (!jsonThemeName) continue;
      if (!tokens[jsonThemeName]) tokens[jsonThemeName] = {};
      if (typeof tokens[jsonThemeName] !== 'object') tokens[jsonThemeName] = {};
      tokens[jsonThemeName][`typography/${token.variableName}`] =
        overrides?.fontFamily?.[token.fontFamily] ?? token.fontFamily;
      tokens[jsonThemeName][`typography/${token.variableName}-size`] =
        `${token.fontSize.toString()}px`;
      // check if overrides.fontWeight is defined
      if (overrides?.fontWeight) {
        const weight = overrides.fontWeight.find(
          (weight) =>
            weight.alias === token.fontWeight.alias && weight.fontFamily === token.fontFamily
        );
        // check if there's a weight that matches the alias and fontFamily
        // if there is, use the value from the overrides
        // if there isn't, use the value from the token
        if (weight) {
          tokens[jsonThemeName][`typography/${token.variableName}-weight`] =
            weight.value.toString();
        } else {
          tokens[jsonThemeName][`typography/${token.variableName}-weight`] =
            token.fontWeight.value.toString();
        }
      } else {
        tokens[jsonThemeName][`typography/${token.variableName}-weight`] =
          token.fontWeight.value.toString();
      }
      if (token.lineHeight.unit === 'PERCENT') {
        tokens[jsonThemeName][`typography/${token.variableName}-line-height`] =
          `${token.lineHeight.value.toString()}%`;
      } else {
        tokens[jsonThemeName][`typography/${token.variableName}-line-height`] = '1.2';
      }
      tokens[jsonThemeName][`typography/${token.variableName}-letter-spacing`] =
        token.letterSpacing.unit === 'PIXELS'
          ? `${token.letterSpacing.value.toString()}px`
          : `${token.letterSpacing.value.toString()}%`;
      tokens[jsonThemeName][`typography/${token.variableName}-text-case`] = token.textCase;
      tokens[jsonThemeName][`typography/${token.variableName}-text-decoration`] =
        token.textDecoration;
      continue;
    }
    if (isEffectToken(token)) {
      const effectValue = [];
      token.effects.forEach((effect) => {
        const {
          color: { r, g, b, a },
          offset: { x, y },
          radius,
          spread,
        } = effect;
        effectValue.push(
          `${x.toString()}px ${y.toString()}px ${radius.toString()}px ${spread.toString()}px rgba(${r.toString()}, ${g.toString()}, ${b.toString()}, ${a.toString()})`
        );
      });
      tokens[`effect/${token.variableName}`] = effectValue.join(', ');
      continue;
    }
    if (isColorOrFloatToken(token)) {
      const modeName = capitalize(token.mode)
        .replace(/[()/]/g, '-')
        .replace(/\s/g, '')
        .replace(/-$/, '');
      if (modeName !== 'mode1') themes[modeName] = {};
      if (token.type === 'color' && !colorTokens.includes(token.name)) {
        colorTokens.push(token.name);
      }
      processTokenValue(token, modeName, jsonThemeName);
    } else {
      console.warn(`${JSON.stringify(token, null, 2)} could not be processed`);
    }
  }
}
function readJson(jsonFileContent, { tokens, themes, project, overrides }) {
  const jsonContent = JSON.parse(jsonFileContent);
  const jsonProjectId = jsonContent.projectId;
  if (!jsonProjectId) {
    throw new Error('project-id is required in the json file');
  }
  if (jsonProjectId.toLowerCase() !== project.toLowerCase()) {
    throw new Error('project-id does not match the project in the config file');
  }
  processTokens(jsonContent.tokens, { tokens, themes, overrides });
  for (const theme of Object.keys(jsonContent.themes)) {
    processTokens(jsonContent.themes[theme], { tokens, themes, overrides }, theme);
  }
  processTokens(jsonContent.uiKit, { tokens, themes, overrides });
  return jsonContent;
}
// 1. Listen for a message from the main application thread
// You can use self.addEventListener or the shorter self.onmessage
self.onmessage = (event) => {
  // Run the script
  const params = event.data;
  try {
    const { bundledJson, srcPath, project, iconsJson, overrides, iconsConfig } = params;
    if (iconsJson) {
      const iconsJsonContent = JSON.parse(params.iconsJson);
      for (const [iconName, iconPath] of Object.entries(iconsJsonContent)) {
        icons[iconName] = iconPath;
      }
    }
    if (!bundledJson) throw new Error('bundledJson not found');
    readJson(params.bundledJson, { tokens, themes, project, overrides });
    const files = runAdapter({
      overrides,
      srcPath,
      tokens,
      icons,
      colors: colorTokens,
      breakpoints,
      themes,
      uiKit,
      project,
      iconsConfig,
    });
    // 3. Send the response back to the main thread
    console.log('...Worker sending response back:', files);
    self.postMessage(files);
  } catch (error) {
    console.error('Error generating theme:', error);
  }
};

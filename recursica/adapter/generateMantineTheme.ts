import type {
  ThemeTokens,
  ContractTokens,
  ExportingProps,
  MantineThemeOverride,
  ExportingResult,
} from '../types';
import { autoGeneratedFile } from '../utils/autoGeneratedFile';
import path from 'path';

interface ContractTokensObject {
  tokens: ContractTokens;
  filename: string;
}

interface GenerateMantineThemeParams {
  mantineThemeOverride: MantineThemeOverride | undefined;
  tokens: ThemeTokens;
  breakpoints: Record<string, string>;
  contractTokens: ContractTokensObject;
  exportingProps: ExportingProps;
}

function parseKey(key: string): string {
  return key.replaceAll('/', '-');
}

interface ThemeTokensObject {
  colors: Record<string, string>;
  spacing: Record<string, string>;
  radius: Record<string, string>;
  fontSizes: Record<string, string>;
  primaryColor: string | undefined;
  white: string | undefined;
}

export interface GenerateMantineThemeOutput {
  mantineTheme: ExportingResult;
  postCss: ExportingResult | undefined;
}

export function generateMantineTheme({
  mantineThemeOverride,
  tokens,
  breakpoints,
  contractTokens: { tokens: contractTokens, filename: contractFilename },
  exportingProps: { outputPath, project, rootPath },
}: GenerateMantineThemeParams): GenerateMantineThemeOutput {
  const themeTokens: ThemeTokensObject = {
    colors: {},
    spacing: {},
    radius: {},
    fontSizes: {},
    primaryColor: mantineThemeOverride?.['1-scale'],
    white: mantineThemeOverride?.background,
  };

  for (const [key, value] of Object.entries(tokens)) {
    if (typeof value === 'object') continue;
    if (key.includes('border-radius')) {
      themeTokens.radius[parseKey(key)] = value;
    }
    if (key.includes('font/size')) {
      themeTokens.fontSizes[parseKey(key)] = `"${value}"`;
    }
  }

  for (const [key] of Object.entries(contractTokens)) {
    if (key.includes('color/') || key.includes('color-on/')) {
      themeTokens.colors[parseKey(key)] = `themeVars['${key}']`;
    }
    if (/font\/(\w+)\/size/.test(key)) {
      themeTokens.fontSizes[parseKey(key)] = `themeVars['${key}']`;
    }
  }

  let postCssFileContent: ExportingResult | undefined;
  if (rootPath) {
    const postCssPath = path.join(rootPath, 'postcss.config.cjs');
    let postCssContent = `${autoGeneratedFile()}\n`;
    postCssContent += `module.exports = {
  plugins: {
    'postcss-preset-mantine': {},
    'postcss-simple-vars': {
      variables: {`;

    for (const [key, value] of Object.entries(breakpoints)) {
      postCssContent += `\n\t\t\t\t'mantine-breakpoint-${key}': '${value}',`;
    }

    postCssContent += `
      }
    }
  }
}`;

    postCssFileContent = {
      content: postCssContent,
      path: postCssPath,
      filename: 'postcss.config.cjs',
    };
  }

  const fileContent = `${autoGeneratedFile()}
import { colorsTuple, createTheme } from '@mantine/core'
import { themeVars } from './${contractFilename.replace('.ts', '')}'

export const mantineTheme = createTheme({
  ${themeTokens.primaryColor ? `primaryColor: ${themeTokens.primaryColor},` : ''}
  ${themeTokens.white ? `white: ${themeTokens.white},` : ''}
  breakpoints: {
    ${Object.entries(breakpoints)
      .map(([key, value]) => `'${key}': '${value}'`)
      .join(',\n\t\t')}
  },
  colors: {
    ${Object.entries(themeTokens.colors)
      .map(([key, value]) => `"${key}": colorsTuple(${value})`)
      .join(',\n\t\t')}
  },
  radius: {
    ${Object.entries(themeTokens.radius)
      .map(([key, value]) => `"${key}": "${value}"`)
      .join(',\n\t\t')}
  },
  fontSizes: {
    ${Object.entries(themeTokens.fontSizes)
      .map(([key, value]) => `"${key}": ${value}`)
      .join(',\n\t\t')}
  }
})`;

  const filename = `Recursica${project}MantineTheme.ts`;
  const mantineThemeFileContent = {
    content: fileContent,
    path: path.join(outputPath, filename),
    filename,
  };

  return { mantineTheme: mantineThemeFileContent, postCss: postCssFileContent };
}

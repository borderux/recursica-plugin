import path from 'path';
import fs from 'fs';
import type { Themes, ExportingProps, ValueToken, ContractTokens, ThemeTokens } from '../types';
import { autoGeneratedFile } from '../utils/autoGeneratedFile';
import { capitalize } from '../utils/capitalize';
interface ThemeContent {
  name: string;
  content: string;
}

export function parseValue(value: ValueToken | string, recursicaTokens: string) {
  if (typeof value === 'object') {
    if (value.collection === 'Tokens') {
      return `${recursicaTokens}["${value.name}"]`;
    }
    if (value.collection === 'Themes') {
      return `themeVars["${value.name}"]`;
    }
  } else if (!isNaN(Number(value))) {
    return `"${value}"`;
  }
  // eslint-disable-next-line @typescript-eslint/no-base-to-string
  return `"${value.toString()}"`;
}

interface VanillaExtractThemesOutput {
  themesFilename: string;
  themeContractFilename: string;
  contractTokens: ContractTokens;
}

export function generateVanillaExtractThemes(
  tokens: ThemeTokens,
  themes: Themes,
  recursicaTokensFilename: string,
  { outputPath, project }: ExportingProps
): VanillaExtractThemesOutput {
  const themesContent: ThemeContent[] = [];
  // Contract tokens
  const themeContractFilename = `Recursica${project}ContractTheme.css`;
  const contractThemeOutputPath = path.join(outputPath, `${themeContractFilename}.ts`);
  const contractTokens: ContractTokens = {};

  const themeDef: Record<string, Record<string, string>> = {};

  for (const [rawThemeName, currentTheme] of Object.entries(themes)) {
    for (const [key, theme] of Object.entries(currentTheme)) {
      const currentThemeName = capitalize(rawThemeName);
      const recursicaTokens = `Recursica${project}Tokens`;

      const themeKey = key.replace(/-([a-z])/g, (_, letter: string) => letter.toUpperCase());

      const themeName = `${currentThemeName}${themeKey}Theme`;

      themeDef[currentThemeName] ??= {};
      themeDef[currentThemeName][themeKey] = themeName;

      const generatedThemeContent = `${autoGeneratedFile()}
import { createTheme } from '@vanilla-extract/css';

import { themeVars } from './${themeContractFilename.replace('.ts', '')}'
import { ${recursicaTokens} } from './${recursicaTokensFilename.replace('.ts', '')}'

export const ${themeName} = createTheme(themeVars,{
  ${Object.entries(theme)
    .map(([key, value]) => {
      contractTokens[key] = null;
      return `"${key}": ${parseValue(value as ValueToken | string, recursicaTokens)}`;
    })
    .join(',\n\t')},
  ${Object.entries(tokens?.[rawThemeName] ?? {})
    .map(([key, value]) => {
      contractTokens[key] = null;
      return `"${key}": ${parseValue(value as ValueToken | string, recursicaTokens)}`;
    })
    .join(',\n\t')}
})`;

      themesContent.push({
        name: themeName,
        content: generatedThemeContent,
      });
    }
  }

  let themesFileContent = autoGeneratedFile();
  for (const theme of themesContent) {
    const themeName = `Recursica${project}${theme.name}`;
    const autoGeneratedThemeFilename = `${themeName}.css.ts`;
    const themeFilePath = path.join(outputPath, autoGeneratedThemeFilename);
    fs.writeFileSync(themeFilePath, theme.content);
    // generate a theme.css.ts where we import all the themes using just 1 variables (1 export)
    themesFileContent += `export { ${theme.name} } from './${autoGeneratedThemeFilename.replace('.ts', '')}';\n`;
    themesFileContent += `import { ${theme.name} } from './${autoGeneratedThemeFilename.replace('.ts', '')}';\n`;
  }
  themesFileContent += `\nexport const Themes = {
  ${Object.entries(themeDef)
    .map(
      ([key, value]) =>
        `"${key}": {
    ${Object.entries(value)
      .map(([key, value]) => `"${key}": ${value}`)
      .join(',\n\t\t')}`
    )
    .join('\n\t},\n\t')}
  }
}`;
  // create the themes.ts file
  const themesTsFileContent = `${autoGeneratedFile()}
export const AvailableThemes = [${themesContent.map((theme) => `"${theme.name}"`).join(', ')}] as const;
export type AvailableThemesType = (typeof AvailableThemes)[number];
`;

  // Contract tokens
  generateVanillaExtractContractorTheme(
    contractTokens,
    themeContractFilename,
    contractThemeOutputPath
  );
  const themesTsFilePath = path.join(outputPath, 'types.ts');
  fs.writeFileSync(themesTsFilePath, themesTsFileContent);

  const themesFilename = `Recursica${project}Themes.css.ts`;
  fs.writeFileSync(path.join(outputPath, themesFilename), themesFileContent);

  return {
    themesFilename,
    themeContractFilename,
    contractTokens,
  };
}

export function generateVanillaExtractContractorTheme(
  contractTokens: ContractTokens,
  contractThemeFilename: string,
  contractThemeOutputPath: string
): string {
  // The theme contract must be generated from the keys of the theme
  const content = `${autoGeneratedFile()}
import { createThemeContract } from '@vanilla-extract/css';

export const themeVars = createThemeContract(${JSON.stringify(contractTokens, null, 2)});
`;
  fs.writeFileSync(contractThemeOutputPath, content);
  return contractThemeFilename;
}
